d1 $ n "0 2 4 6 0 2 6 8" # sound "cyclo"

-- xfade. orbit name is argument.

d1 $ s "hh*16?"

xfade 1 $ s  "909*16?"

-- djf. lpf/hpf with 0-1 argument.

d1 $ s "hh*16?" # djf sine

-- hbrick. spectral high pass with 0-1 argument.

d1 $ s "hh*16?" # hbrick sine

-- lbrick. spectral low pass with 0-1 argument.

d1 $ s "hh*16?" # lbrick sine

-- shape. parametric amplifier with 0-1 argument.

d1 $ s "hh*16?" # shape sine

-- crush. bitcrush with 1-16 argument

d1 $ s "wobble" # crush "[2 | 16]"

-- squiz. weird pitchshifter with arguments in multiples of two.

d1 $ s "wobble" # squiz "[2 | 16]"

-- SAMPLES

-- striate. cuts sample into the parameter, plays progressive cut per loop. (can't use with pattern, but we'll get to that with "slice").

d5 $ striate 3 $ s "print:0 print:1 print:2"

-- begin. where to begin in sample.

d6 $ s "bev" # begin 0.5

-- end. where to end in sample.

d6 $ s "bev" # begin 0.5 # end 0.65

-- loop. argument is to stretch the sample over these many patterns, then start again.

d6 $ loopAt 8 $ s "bev"

-- slice. first argument is how many slices to make of the sample, second argument is which sample to choose per pattern.

d6 $ slice 16 "[2|4|8|16]" $ s "bev"

-- random slice. argument is how many slices to make of the sample, which one is random.

d6 $ randslice 8 $ s "bev"

-- advanced pattern transformation

--one hit. NO ORBIT!

once $ s "xmas"

-- arp, slow, hurry

d2 $ slow 2 $ note (arp "<converge diverge pinkyup pinkyupdown thumbup thumbupdown>" "<d'major a'major>") # s "newnotes"

-- [sometimes and it's cousins](https://tidalcycles.org/docs/reference/randomness/#the-sometimes-family)

-- palindrome. reverses pattern every other cycle.

d2 $ palindrome $ note (arp "<converge diverge pinkyup pinkyupdown thumbup thumbupdown>" "<d'major a'major>") # s "newnotes"

d2 $ sometimes (palindrome) $ note (arp "<converge diverge pinkyup pinkyupdown thumbup thumbupdown>" "<d'major a'major>") # s "newnotes"

-- degrade. randomly removes events from a pattern half the time.

d2 $ degrade $ note (arp "<converge diverge pinkyup pinkyupdown thumbup thumbupdown>" "<d'major a'major>") # s "newnotes"

d2 $ sometimes (degrade) $ degrade $ note (arp "<converge diverge pinkyup pinkyupdown thumbup thumbupdown>" "<d'major a'major>") # s "newnotes"

-- degradeBy. randomly removes events from a pattern a specified percentage of the time.

d3 $ degradeBy 0.3 $ "reverbkick*4"

-- linger. truncates a pattern then repeats the truncation.

d2 $ linger "[0.25 0.5 0.75]" $ degrade $ note (arp "<converge diverge pinkyup pinkyupdown thumbup thumbupdown>" "<d'major a'major>") # s "newnotes"

-- [chunk'. divides a pattern into parts, applies function to each part, reverses some(that's what the apostrophe at the end is about)](https://tidalcycles.org/docs/reference/alteration/#chunk-1)

d5 $ chunk' 3 (hurry 2) $ n ("7 2 [3 2] ~") # s "print"

-- operators a la rachelle with samples (pentatonic clusters + just a *touch* of randomness)

d5 $ n ("1 ~ 2 [3 2] ~" |+ irand 11) # s "print"

-- [SuperDirt Synths!](https://tidalcycles.org/docs/reference/synthesizers)
-- Additive. SuperGong.
d1 $ n "0 2 4 6 0 2 6 8"
  # s "supernoise"
  # voice 0.5 -- 'tone' knob
  # decay sine -- harmonics decay
  # accelerate sine -- pitch glide

hush

--Subtractive. SuperChip.
d2 $ n "0 2 4 6 0 2 6 8"
  # s "superchip"
  # slide sine -- linear pitch glide
  # rate sine -- repeats the above glide “n” times (can be fractional or negative)
  # accelerate sine -- 'overall' glid
  # pitch2 sine -- control the ratio of harmonics
  # pitch3 sine -- control the ratio of harmonics
  # voice sine -- causes variations in the levels of the 3 oscillators

-- Subtractive. SuperReese.
d3 $ n "0 2 4 6 0 2 6 8"
  # s "superreese"
  # accelerate sine -- 'overall' glid
  # voice sine -- causes variations in the levels of the 3 oscillators
  # detune sine -- detune amount

-- Modeling. SuperHammond with voices:
-- 0. bass violin 16’
-- 1. tibia 8’
-- 2. bassoon 8’
-- 3. french trumpet 8’
-- 4. string ensemble
-- 5. Blues
-- 6. Jazz 1
-- 7. Full Shout
-- 8. Bro’ Jack
-- 9. Jazz 2
d4 $ n "0 2 4 6 0 2 6 8"
  # s "superhammond"
  # voice 2

-- Shepard tone on cycle!
d5 $ n "0 2 4 6 0 2 6 8"
  # s "cyclo"
  # accelerate sine -- pitch-glide amount

-- gabor grain
d6 $ n "0 2 4 6 0 2 6 8"
  # s "gabor"

-- band limited impulse
d7 $ n "0 2 4 6 0 2 6 8"
    # s "imp"
    # accelerate sine -- pitch-glide amount

hush

import Sound.Tidal.Chords
chordList
chordTable

d1
$ often (slow 16)
$ rolledBy sine
$ n "c'min9'o" --o
  # sound "cyclo"

scaleList
scaleTable

d1
$ segment 16
$ note (scale "hexAeolian" $ floor <$> (range 0 16 sine))
  # sound "gabor"

hush

-- [off & fx. hocketing potential.](https://tidalcycles.org/docs/reference/time/#off)
d7 $ off 0.5 (# squiz 4)
$ n ("~ 7 2 [3 2]" |+ irand 6) # s "gabor"

-- spin. argument is number of copies, then copies are offset in time and space! amazing for multichannel](https://tidalcycles.org/docs/reference/time/#spin)

d7 $ spin 3 $ n ("~ 7 2 [3 2]" |+ irand 6) # s "gabor"

-- poly meter? poly rhythm?...euclidean rhythm?
-- https://www.youtube.com/watch?v=bKazVnHh2w4 (@1:55)

--Polyrhythmic sequence with argument for steps per cycle
d1 $ s "{bd cp hh}%8"

hush

--Euclidean Rhythm
-- syntax sugar
--MiniTidal Euclidean Rhythm
d1 $ "reverbkick(5,8)"
-- this was short for (third argument is offset)
d1 $ "e(5,8,2)" # s "reverbkick"
-- which itself was short for
d1 $ euclid 5 8 $ s "reverbkick"
-- in all of these:
  -- first argument is the events per cycle
  -- second argument is the steps per cycle
  -- advantages of longer syntax is more places to add parameters
-- this is also the same:
d1 $ distrib [9,16] $ s "reverbkick"
-- but, there is a third argument here too (just play this many)
d1 $ distrib [9,16,"<5 4 3 2 1>"] $ sound "reverbkick"

-- EXCERPTS FROM ALEX MCLEAN'S WORKSHOPS

-- Remember that waveforms don't have structure, so don't produce
-- events until you use something like 'segment', which in the example
-- above picks 16 notes per cycle.
-- There's also a complication that waveforms produce 'floating point'
-- decimal numbers, but scale only accepts 'integers' - whole numbers.
-- The 'floor <$>' bit converts from decimal to whole numbers.  The
-- "range 0 14" bit converts from the usual range of 0 to 1 to the
-- given range of 0 to 14.

-- We can make this more exciting by patterning the range:
d1
$ segment 4
$ n (scale "minor" $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine))
  # sound "superhammond"
  # legato 0.5
  # lpf 1000
  # lpq 0.1

-- And maybe even more exciting by using 'struct' to pattern the
-- rhythm using Euclidean syntax.. Taking the opportunity to pattern
-- the lpf (low pass filter) as well:
d1
$ struct "t(<3 5>,8)"
$ n (scale "minor" $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine))
  # sound "superhammond"
  # legato 0.5
  # lpf (range 400 5000 saw)
  # lpq 0.1

-- Using scales in this way allows us to play with movement while
-- still making tunes that make 'sense'. Here I add together
-- waveforms to create some longer-form movement:
d1 $ segment 16
$ n (scale "minor" $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"))
  # sound "superhammond"
  # legato 0.5
  # lpf (range 400 5000 saw)
  # lpq 0.1

-- Back with the struct:
d1
$ struct "t(9,16)"
$ n (scale "minor" $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"))
    # sound "superhammond"
    # legato 0.5
    # lpf (range 400 5000 saw)
    # lpq 0.1

-- And with an 'off' going up an octave:
d1
$ off 0.25 (|+ n 12)
$ struct "t(<9 7>,16)"
$ segment 16
$ n (scale "minor" $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"))
      # sound "superhammond"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1
-- Note that in the above the 'off' is outside of the 'scale'
-- function, So we're back in 12-TET land, so add '12' to go up an
-- octave, rather than the number of notes in the minor scale (7)



-- Binary patterns
-- The patterns you send to SuperDirt tend to contain values of type
-- String (for words), Double (for decimal numbers) or Int (for whole
-- numbers). One pattern type you probably won't send to SuperDirt is
-- of type Bool - short for Boolean.

-- Boolean values can be either True or False. You've probably seen
-- then used with with 'struct', e.g.:

d1 $ struct "t f f f t f f f t f f f " $ sound "909"

-- 'struct' provides structure for the pattern on the right; whenever
-- there's a 't' (i.e., a true value) in the boolean pattern, the
-- snare fires.

-- It works with euclidean syntax too:
d1 $ struct "t(3,8)" $ sound "wobble"

-- The above creates a new pattern with three events per cycle,
-- according to a Euclidean pattern.

-- Lets have a look at that euclidean pattern:
drawLine $ struct "t(3,8)" "a"

-- So what do you think would happen if you changed that 't' (for
-- true) for an 'f' (for false)? Lets try:
drawLine $ struct "f(3,8)" "a"

-- Lets listen to that structure too:
d1 $ struct "f(3,8)" $ sound "gabba:4"

-- You can see and hear that the *inverse* of the Euclidean pattern is
-- played. What was true, is now false, and vice-versa.. It's the
-- 'empty' steps which get the true values, and which we end up
-- hearing.

-- This is clearer if we play a t(3,8) against an inverted f(3,8):
d1 $ stack [struct "t(3,8)" $ sound "gabba:4",
            struct "f(3,8)" $ sound "gabba:5"
           ]

-- Filling in patterns like this is a lot of fun, and there's a
-- function called 'stitch' that makes it easier:
d1 $ stitch "t(3,8)" (sound "gabba:4") (sound "gabba:5")
-- You only have to give the boolean pattern once, 'stitch' takes care
-- of inverting the pattern for the second pattern. It's called
-- 'stitch', because it's like going up and down to stitch two things
-- together...

-- You don't have to use the Euclidean syntax, you can just right them
-- out by hand:
d1 $ stitch "t f t t f f t f" (sound "print:4") (sound "909")

-- .. and use the usual mininotation syntax:
d1 $ stitch "t f t [t f]*2 f ~ t f" (sound "print:4") (sound "909")
  # room 0.2 # sz 0.8

-- DEMO CUSTOM SC SYNTH!
